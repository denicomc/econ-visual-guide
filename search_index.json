[
["index.html", "Guide to Economic Data + Interactive Visualization in R", " Guide to Economic Data + Interactive Visualization in R As of January 2018 Jeff Chen / Chief Innovation Officer Andrea Batch / Economist Getting started with data visualization involves climbing a learning curve. This guide straightens the curve through intuitive tutorials focused on visualization of economic data. It is an evolving document that will grow and be refined. In the current version, two topics are covered: Accessing economic data via the BEA API using BEA’s R Library Creating interactive maps "],
["access-economic-data-via-the-bea-api.html", "Chapter 1 Access Economic Data via the BEA API 1.1 Searching for data 1.2 Get Data", " Chapter 1 Access Economic Data via the BEA API While BEA data can be accessed via the official website, programming-inclined users can easily access data through BEA’s Application Programming Interface (API), which is a common way of querying and retrieving data. For R Users, BEA has developed the bea.R library that is optimized for econometricians, statisticians, and data analysts. bea.R can be installed directly from CRAN: install.packages(&quot;bea.R&quot;) Upon installation, load the library: library(bea.R) In order for BEA to understand user needs and to ensure a consistent, high level of service, the BEA API requires an API key – a simple 36 character code that opens access to data. The API key is free, asking for your name and email address: https://www.bea.gov/API/signup/index.cfm. Upon submitting an API key request, the key will be emailed to you. Once you have received your BEA API key, save it to a variable to make it easier to use later: beaKey &lt;- &quot;[36-Character-Key]&quot; 1.1 Searching for data Much like using an index in a textbook, making a successful data retrieval request to the API requires specific information (e.g. variable series code, frequency, geographic units). The R library’s search functionality provides facility to easily surface the necessary information. Search is facilitated by the beaSearch() method, which requires two arguments: keyword and beaKey. For example, the following keyword search returns a list of all datasets in which the term “Personal Consumption Expenditures” appears. One particularly important aspect of the search result is a pre-populated API call that jump starts the querying process. beaSearch(&#39;Personal Consumption Expenditures&#39;, beaKey) Table 1.1: Example results from through search interface. SeriesCode DPCERL DPCEDX RowNumber 20 20 LineDescription Personal consumption expenditures Personal consumption expenditures LineNumber 2 2 ParentLineNumber Tier 0 0 Path 2 2 TableID 1 10 DatasetName NIPA NIPA TableName Table 1.1.1. Percent Change From Preceding Period in Real Gross Domestic Product Table 1.1.6D. Real Gross Domestic Product, Chained (1992) Dollars ReleaseDate Dec 21 2017 8:30AM Aug 6 2015 12:00AM NextReleaseDate Jan 26 2018 8:30AM Jan 1 1900 12:00AM MetaDataUpdated 2017-12-21T21:24:27.427 2017-12-21T21:24:27.427 Account National National apiCall beaGet(list(‘UserID’ = ‘[your_key]’, ‘Method’ = ‘GetData’, ‘DatasetName’ = ‘NIPA’, ‘TableID’ = ‘1’, …)) beaGet(list(‘UserID’ = ‘[your_key]’, ‘Method’ = ‘GetData’, ‘DatasetName’ = ‘NIPA’, ‘TableID’ = ‘10’, …)) Key NA NA Desc NA NA Parameter NA NA For some keyword searches, a sufficiently specific search will yield only a few results. Given the vast amount of data that BEA publishes, the search functionality will often return a sizable amount of candidate results. This may be more easily evaluated by specifying asHtml = TRUE, which presents search results in an interactive, searchable table. beaSearch(&#39;Final sales of computers to domestic purchasers&#39;, beaKey, asHtml = TRUE) 1.2 Get Data Using the sample API call from the above example, we will retrieve Personal Consumption Expenditures from Table 1.1.1. Percent Change From Preceding Period in Real Gross Domestic Product. But in short, it is TableID = 1 from the NIPA dataset. Below, the list object specifies the relevant parameters, requesting the data at a quarterly frequency for all years. specs &lt;- list( &#39;UserID&#39; = beaKey, &#39;Method&#39; = &#39;GetData&#39;, &#39;datasetname&#39; = &#39;NIPA&#39;, &#39;TableID&#39; = &#39;1&#39;, &#39;Frequency&#39; = &#39;Q&#39;, &#39;Year&#39; = &#39;2010,2012,2013,2014&#39;, &#39;ResultFormat&#39; = &#39;json&#39; ) To retrieve a limited selection of multiple years, list all the years you want to retrieve. For example, to retrieve data for 2010 through 2014, use &quot;Year&quot;=&quot;2010,2012,2013,2014&quot;. The beaGet() function can use the spec list to retrieve data. By default, the data are returned in wide form – each row is an indicator and each time period’s data is represented as a separate column. df &lt;- beaGet(specs); head(df, 3) ## TableID TableName SeriesCode LineNumber ## 1: 1 T10101 A191RL 1 ## 2: 1 T10101 DPCERL 2 ## 3: 1 T10101 DGDSRL 3 ## LineDescription METRIC_NAME ## 1: Gross domestic product Fisher Quantity Index ## 2: Personal consumption expenditures Fisher Quantity Index ## 3: Goods Fisher Quantity Index ## CL_UNIT UNIT_MULT DataValue_2010Q1 DataValue_2010Q2 ## 1: Percent change, annual rate 0 1.7 3.9 ## 2: Percent change, annual rate 0 2.2 3.3 ## 3: Percent change, annual rate 0 4.0 5.2 ## DataValue_2010Q3 DataValue_2010Q4 DataValue_2012Q1 DataValue_2012Q2 ## 1: 2.7 2.5 2.7 1.9 ## 2: 2.6 4.2 2.4 0.7 ## 3: 3.8 7.6 4.9 1.1 ## DataValue_2012Q3 DataValue_2012Q4 DataValue_2013Q1 DataValue_2013Q2 ## 1: 0.5 0.1 2.8 0.8 ## 2: 1.1 1.1 1.9 0.8 ## 3: 2.7 2.3 5.7 1.3 ## DataValue_2013Q3 DataValue_2013Q4 DataValue_2014Q1 DataValue_2014Q2 ## 1: 3.1 4.0 -0.9 4.6 ## 2: 1.9 3.4 1.9 3.5 ## 3: 2.9 4.0 2.4 6.2 ## DataValue_2014Q3 DataValue_2014Q4 ## 1: 5.2 2.0 ## 2: 3.9 5.1 ## 3: 4.5 5.7 For some use cases, in particular for time series models, obtaining the data in long form is desirable, which can be done by setting asWide = FALSE. df &lt;- beaGet(specs, asWide = FALSE); head(df, 3) In other cases, it may be more desirable to obtain the data in a form in which each column represents a variable, which is accomplished by setting iTableStyle = FALSE. df &lt;- beaGet(specs, iTableStyle = FALSE) head(df, 3) "],
["interactive-maps.html", "Chapter 2 Interactive Maps 2.1 Get BEA data 2.2 Get shapefile 2.3 Process and join data 2.4 Set styles 2.5 Render", " Chapter 2 Interactive Maps Interactive maps have become commonplace in the web’s tools for communicating geographic information. While they are user friendly representations, building even the simplest of maps requires some basic knowledge of how the data are structured. For example, the map below plots the per capita personal income growth for 2016. Figure 2.1: What will be built in this session In order to render the color-coded polygons as a chloropleth map, we need two types of information: the geometries of US states and their economic attributes. The shape of each state is stored in a special data format, such as a shapefile or GeoJSON, that contains geographic coordinates and properties that indicate the type of shape (e.g. line, polygon, point). The geometries on their own are useful to render the outline of each state, but do not usually come furnished with economic data. Each shape is associated with an identifier that can be used to join new data, such as economic attributes. Figure 2.2: Process flow for creating map. Below, in order to construct a map containing growth of per capita personal income and personal expenditures by state, we layout and illustrate a five step process: Get BEA data from the API and make adjustments Get US state shapefile from the US Census Bureau Join the data Set visual styles and functionality Render map 2.1 Get BEA data Using the R library’s beaGet() function, we will make two requests via the BEA API: Annual Per Capita Personal Income by State as available in table CA1 Annual Per Capita Personal Expenditure by State as available in table C3 In order to calculate growth, we will request two years of data: 2015 and 2016. In the code below, notice that the request parameters are first inserted in a list() object, then passed to the beaGet() function. The result is a data.table containing time series data. library(bea.R) beaKey = &quot;36-character key goes here&quot; #Personal Income Per Capita #Specify request parameters pcinc_req &lt;- list(UserID = beaKey, Method = &#39;getdata&#39;, LineCode = &#39;1&#39;, TableName = &#39;CA1&#39;, Frequencu = &#39;a&#39;, DatasetName = &#39;regionalincome&#39;, Year = &#39;2015,2016&#39;, GeoFIPS = &#39;state&#39;) #Send parameters via beaGet pcinc_regional &lt;- beaGet(pcinc_req) # Personal Consumption (IndustryID = 1 indicates all) #Specify request parameters pcpce_req &lt;- list(UserID = beaKey, Method = &#39;GetData&#39;, DatasetName = &#39;RegionalProduct&#39;, Component = &#39;PCPCE_SAN&#39;, IndustryID = &#39;1&#39; , Year = &#39;2015,2016&#39;, GeoFIPS = &#39;state&#39;, Frequency = &#39;a&#39;) #Send parameters via beaGet pcpce &lt;- beaGet(pcpce_req) 2.2 Get shapefile Next, a geometry file is required. The US Census Bureau publishes shapefiles for select geographic areas, including US states. Boundary files can be downloaded from https://www.census.gov/geo/maps-data/data/tiger-cart-boundary.html. BEA has developed a simple function to download, unzip, and load Census shapefiles. This function requires the rgdal package to load shapefiles. library(rgdal) getShape &lt;- function(url){ # # Download, unzip and load shapefile from URL # # Args: # url = URL to zip file containing shapefile # # Returns: # # Loaded shapefile #Create temp objects temp_dir &lt;- tempdir() temp_file &lt;- tempfile() #Download and unzip file download.file(url, temp_file,method=&quot;libcurl&quot;) unzip(temp_file, exdir = temp_dir) #Load shapefile file_prefix &lt;- grep(&quot;*\\\\.shp$&quot;,list.files(temp_dir), value = TRUE) file_prefix &lt;- gsub(&quot;\\\\.shp&quot;, &quot;&quot;, file_prefix) return(readOGR(temp_dir, layer = file_prefix, verbose = FALSE)) } Upon loading the function, we now can import a US state shapefile direct from the Census website. url &lt;- &quot;http://www2.census.gov/geo/tiger/GENZ2016/shp/cb_2016_us_state_20m.zip&quot; states &lt;- getShape(url) In its most basic form, the shapefile yields a map of state outlines. plot(states) 2.3 Process and join data With the shapefile and indicators loaded, we can inspect the layout using the head() function. From the geometry side (e.g. states), the STATEFP field is a Federal Information Processing (FIPS) code, a hierarchical classification system to uniquely identify geographic units. This field will be used to match between the shapefile and each of the indicator files. ## STATEFP STATENS AFFGEOID GEOID STUSPS NAME LSAD ALAND ## 0 23 01779787 0400000US23 23 ME Maine 00 79885221885 ## 1 15 01779782 0400000US15 15 HI Hawaii 00 16634100855 ## 2 04 01779777 0400000US04 04 AZ Arizona 00 294198560125 ## 3 05 00068085 0400000US05 05 AR Arkansas 00 134771517596 ## 4 10 01779781 0400000US10 10 DE Delaware 00 5047194742 ## AWATER ## 0 11748755195 ## 1 11777698394 ## 2 1027346486 ## 3 2960191698 ## 4 1398720828 On the indicator side (e.g. pcpce and pc_regional), the GeoFips field will be required to merge with the geometry file and the the DataValue_ fields will be converted into annual percentage growths. The GeoFips field will need to be changed to match the STATEFP format by extracting only the first two digits of the identifier. head(pcpce, 5) Code GeoFips GeoName CL_UNIT UNIT_MULT DataValue_2015 DataValue_2016 PCPCE_SAN-1 00000 United States dollars 0 38417 39664 PCPCE_SAN-1 01000 Alabama dollars 0 30577 31336 PCPCE_SAN-1 02000 Alaska dollars 0 48700 49547 PCPCE_SAN-1 04000 Arizona dollars 0 33922 34580 PCPCE_SAN-1 05000 Arkansas dollars 0 30051 31117 Data Manipulation To calculate the annual growth, we simply use the formula: \\[\\Delta y_t = 100 \\times (\\frac{y_t}{y_{t-1}}-1) = 100 \\times (\\frac{\\text{DataValue_2016}}{\\text{DataValue_2015}}-1) \\] In addition, the GeoFips code can be shortened to the first two digits using the substr() function. The attach() function is used so that the name of variables within a specified dataframe are treated as global variables, removing the need to specify the data frame each time a variable is called and allowing the code to be more compact. #Calculate Per Capita PCE Growth attach(pcpce) ## The following objects are masked from pcpce (pos = 4): ## ## CL_UNIT, Code, DataValue_2015, DataValue_2016, GeoFips, ## GeoName, UNIT_MULT ## The following objects are masked from pcpce (pos = 5): ## ## CL_UNIT, Code, DataValue_2015, DataValue_2016, GeoFips, ## GeoName, UNIT_MULT pcpce$pcpce.growth &lt;- 100 * (DataValue_2016/DataValue_2015 - 1) pcpce$STATEFP &lt;- substr(GeoFips,1,2) pcpce &lt;- pcpce[, c(&quot;STATEFP&quot;, &quot;pcpce.growth&quot;)] detach(pcpce) #Calculate Per Capita PCE Growth attach(pcinc_regional) ## The following objects are masked from pcpce (pos = 4): ## ## CL_UNIT, Code, DataValue_2015, DataValue_2016, GeoFips, ## GeoName, UNIT_MULT ## ## The following objects are masked from pcpce (pos = 5): ## ## CL_UNIT, Code, DataValue_2015, DataValue_2016, GeoFips, ## GeoName, UNIT_MULT pcinc_regional$pcinc.growth &lt;- 100 * (DataValue_2016 / DataValue_2015 - 1) pcinc_regional$STATEFP &lt;- substr(GeoFips,1,2) pcinc_regional &lt;- pcinc_regional[, c(&quot;STATEFP&quot;, &quot;pcinc.growth&quot;)] detach(pcinc_regional) Merge With the data processed, we will use the merge() function to join the economic data frames together using the newly created STATEFP variable. Then this merged data frame is combined with the states shapefile. #Merge both per capita data sets pcinc_regional &lt;- merge(pcinc_regional, pcpce, by = &quot;STATEFP&quot;) #Merge shapefile to the data set states &lt;- merge(states, pcinc_regional, by = &quot;STATEFP&quot;) states &lt;- states[!is.na(states@data$pcinc.growth),] 2.4 Set styles A color palette needs to be defined in order for colors to be rendered in a map. Color palettes require two pieces of information: number of bins and color progression. Bins are defined by the cutoffs in a specified variable. Below, we use the seq() function to produce a sequence of equally spaced thresholds between a minimum value (min()) and maximum value (max()). floor() and ceiling() are used to round values to the next smallest and next largest number, respectively. The colorBin() function available in the leaflet library creates color palettes using three parameters: a color palette (e.g. “Reds”, “Greens”), a domain (e.g. a variable like pcinc.growth), and the thresholds that define the bins (defined above). Each pcinc.growth and pcpce.growth will have their own palletes labeled pal1 and pal2, respectively. #Load leaflet library library(leaflet) #Set upbins attach(states@data) bins1 &lt;- seq(floor(min(pcinc.growth)), ceiling(max(pcinc.growth)), 1) pal1 &lt;- colorBin(&quot;Blues&quot;, domain = pcinc.growth, bins = bins1) bins2 &lt;- seq(floor(min(pcpce.growth)), ceiling(max(pcpce.growth)), 1) pal2 &lt;- colorBin(&quot;Reds&quot;, domain = pcpce.growth, bins = bins2) detach(states@data) Most maps also tend to be furnished with tooltips, which are a labels or comments that popup when a mouse/cursor moves over objects in the map. The sprintf() function helps to blend text and numbers as contained in variables. Below, simple HTML text is used to create three lines in which text and numeric values are populated where %s and %g appear, respectively. #Pop Up Label labs &lt;- sprintf( &quot;&lt;strong&gt;%s&lt;/strong&gt;&lt;br&gt; PI: %g percent &lt;br&gt; PCE: %g percent&quot;, states@data$NAME, round(states@data$pcinc.growth,2), round(states@data$pcpce.growth,2)) %&gt;% lapply(htmltools::HTML) 2.5 Render With all the settings sorted, we now can begin to put together the map itself. The map will be furnished with four attributes: A map canvas that is centered on the middle of the US A base layer that provides context Two layers of state polygons that are color coded based on each pcinc.growth and pcpce.growth Toggles for the polygons To start, we will create a map object that specifies the shapefile and the canvas extent. To that object we use the %&gt;% operator to set the view by centering the map on longitude = -96.5 and latitude = 37.7. Notice that the rendered object is blank as we have not yet specified the base layer or polygons. #Set canvas map_object &lt;- leaflet(states, width = &quot;100%&quot;, height = &quot;500px&quot;) %&gt;% setView(-96.5, 37.7, 4) Next, we add web map tiles from CartoDB using the addProviderTiles. Browse other free tiles at http://leaflet-extras.github.io/leaflet-providers/preview/. #Add background map_object &lt;- map_object %&gt;% addProviderTiles(provider = &quot;CartoDB.Positron&quot;) Next, we at the polygons, which is a fairly verbose step. But in short: For each polygon, we associate it with a group that will later be used in the toggle controls. The fillColor is derived from the previously specified palette objects. The weight and color indicate the thickness and border color of each polygon. The fillOpacity indicates how transparent the polygon shading will be (between 0 and 1). highlightOptions indicate how each polygon’s colors will change when a cursor moves over. label uses the labs object to create the tooltip popup. labelOptions control how the tooltip looks. #Add data map_object &lt;- map_object %&gt;% addPolygons(group = &quot;Personal Income&quot;, fillColor = ~pal1(pcinc.growth), weight = 1, color = &quot;white&quot;, fillOpacity = 0.5, highlight = highlightOptions( weight = 2, color = &quot;#666&quot;, fillOpacity = 0.4), label = labs, labelOptions = labelOptions( style = list(&quot;font-weight&quot; = &quot;normal&quot;, padding = &quot;3px 8px&quot;), textsize = &quot;15px&quot;, direction = &quot;auto&quot;)) %&gt;% addPolygons(group = &quot;Personal Consumption&quot;, fillColor = ~pal2(pcpce.growth), weight = 1, color = &quot;white&quot;, fillOpacity = 0.5, highlight = highlightOptions( weight = 2, color = &quot;#666&quot;, fillOpacity = 0.4), label = labs, labelOptions = labelOptions( style = list(&quot;font-weight&quot; = &quot;normal&quot;, padding = &quot;3px 8px&quot;), textsize = &quot;13px&quot;)) Lastly, addLayersControl are added to the map object to define the polygon layers that can be toggled. map_object &lt;- map_object %&gt;% addLayersControl( overlayGroups = c(&quot;Personal Income&quot;, &quot;Personal Consumption&quot;)) The result is a fully functional interactive map that can help build and support narratives on the economy over space. "]
]
